# 라우팅 알고리즘

## 정의
- 송신 측에서부터 수신 측 라우터의 네트워크를 통과하는 최적의 경로를 결정하는 알고리즘이다.

## 분류
### 중앙 집중형 라우팅 알고리즘(Global)
- 네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산한다. 즉, 모든 라우터가 연결 상태와 링크 비용을 알고 있다는 것이다. 
- Link State 알고리즘이 여기에 속하며 주로 다익스트라 알고리즘을 사용한다.

### 분산 라우팅 알고리즘(Decentralized)
- 최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다. 
- 어떤 라우터도 모든 링크 비용에 대한 완전한 정보를 갖고 있지 않지만, 각 라우터는 자신에게 연결된 인접 노드에 대한 링크 비용 정보를 알고 있다. 
- 이후 반복된 계산과 인접 노드와의 정보 교환을 통해 목적지까지의 최소 비용 경로를 계산한다. 
- Distance Vector 알고리즘이 여기 속하며 주로 벨만-포드 알고리즘을 사용한다.

---
### 정적 라우팅 알고리즘 
- 경로의 변경이 느리고 사람이 직접 링크에 대한 비용을 수정해야 한다. 
- 규모가 큰 네트워크에서 일일이 수정하기 불가능하며 사람이 하기에 역부족이다.
### 동적 라우팅 알고리즘 
- 네트워크 트래픽 부하나 topology 변화에 따라 라우터가 자체적으로 경로를 바꾼다. 
- 동적 알고리즘은 주기적으로 topology나 링크 비용의 변경에 직접적으로 응답하는 방식으로 수행된다. 
- 동적 알고리즘은 네트워크 변화에 더 빠르게 대응할 수 있지만 경로의 loop나 경로 진동과 같은 문제에 취약하다.


## Link State 알고리즘
- 중앙 집중형 알고리즘에 속한다. 
- 즉, 모든 라우터(노드)가 모든 링크(간선)의 비용을 알고 있기 때문에 다익스트라 알고리즘을 이용해 최적의 경로를 계산할 수 있다. 
- 한 노드(source node)에서 다른 모든 노드까지의 최적경로를 계산해 Routing Table에 저장해 놓는다.

### 예시
<p align="center"><img src="../images/dijkstra_1.png" width="700"></p>

<p align="center"><img src="../images/dijkstra_2.png" width="700"></p>

- 위와 같은 네트워크 상황이 있다고 가정하자.
- 시작점을 u로 두고, u 노드에서 갈 수 있는 노드들의 값들을 계산해보면 [표 1] step1 행의 값들과 같다. 이 중에서 가장 cost가 적은, w 노드로 가는 길이 처음으로 선택될 것이다.
- 다음으로, w 노드로 가는 길이 선택됨과 동시에, 다시 u 노드에서 갈 수 있는 노드들의 값들을 계산해보면, [표 1]의 step2 행의 값들과 같다.
- 이 때, u에서 v로 가는 경로의 cost의 경우, 직접 가는 길과 이미 알려진 w를 거쳐 가는 길 중 cost가 적은 값을 기준으로 다시 업데이트 된 것을 확인할 수 있다. (cost 7 -> cost 6)
- 결국 step2 에서는 가장 cost가 적은 x 노드로 가는 길이 선택될 것이다.
- 이런 과정으로 계속해서 진행하면 [표 1]과 같은 값들이 나올 것이고, 이를 통해 만들어진 그래프는 아래 [그림 2]와 같다.

<p align="center"><img src="../images/dijkstra_3.png" width="700"></p>

## Distance Vector 알고리즘
- 분산형 알고리즘에 속한다. 
- 즉, 각 노드는 자신에게 연결된 이웃의 링크의 비용만 알고 있기 때문에 벨만-포드 알고리즘을 이용해 최적의 경로를 계산할 수 있다. 
- DV 알고리즘은 반복적이고 비 동적이며 분산적이다. 이웃끼리 반복해서 정보를 교환해 최적의 경로를 갱신하는 식이다.

### 예시
<p align="center"><img src="../images/bellman_ford_1.png" width="700"></p>

- [그림 3]과 같은 네트워크 상황이 있다고 가정하자.
- u 노드에서 z 노드로 가는 최단 경로를 찾고싶다고 할 때,
```
step 1. 우선, Dv(z) = 5, Dx(z) = 3, Dw(z) = 3 임을 계산한다. (Dx(y)는 x에서 y까지의 최단경로)
step 2. Du(z)를 아래 식을 이용해 계산한다.
```

<p align="center"><img src="../images/bellman_ford_2.png" width="700"></p>

- 하지만 여기서 의문인 것은, step 1의 Dv(z), Dx(z), Dw(z)의 값들은 어떻게 구하냐는 것이다.
- Bellman-Ford 알고리즘은 기본적으로 Distance Vector 알고리즘이므로, 해당 값들은 그냥 이미 알고 있는다고 가정하고 진행하기 때문에 u 노드 입장에서는 이를 전혀 신경쓰지 않는다.
- Dv(z)의 경우, v 노드에서 위의 step1, 2 과정을 거쳐 나온 결과가 5인 것이며, u 노드는 이 정보를 이용할 뿐, 구체적으로 어떤 과정을 통해 해당 값이 나왔는지는 고려하지 않는다.
